查询 CPU 配置
SELECT 
    INSTANCE_NAME, 
    NUM_CPUS,               -- 逻辑 CPU 数量
    STATISTICS_UPDATED      -- 信息更新时间
FROM GV$OSSTAT 
WHERE STAT_NAME = 'NUM_CPUS';

-- 进一步查看 CPU 的负载情况（Load）
SELECT 
    INST_ID, 
    STAT_NAME, 
    VALUE 
FROM GV$OSSTAT 
WHERE STAT_NAME IN ('LOAD', 'IDLE_TICKS', 'USER_TICKS', 'SYS_TICKS');

查询 内存 (SGA & PGA) 配置
-- 查看当前 SGA（全局内存）和 PGA（连接私有内存）的总大小
SELECT 
    INST_ID,
    NAME, 
    ROUND(VALUE/1024/1024/1024, 2) AS GB 
FROM GV$PARAMETER 
WHERE NAME IN ('sga_target', 'pga_aggregate_target', 'memory_target');

-- 查看内存的实际使用分布（Buffer Cache 越大，对 SSD 的压力越小）
SELECT 
    INST_ID,
    COMPONENT, 
    CURRENT_SIZE/1024/1024/1024 AS SIZE_GB 
FROM GV$SGA_DYNAMIC_COMPONENTS 
WHERE COMPONENT IN ('DEFAULT buffer cache', 'shared pool');

查询 磁盘 (ASM) 信息
-- 查看磁盘组（Disk Group）的总容量和剩余空间
SELECT 
    NAME, 
    STATE, 
    TYPE,                         -- NORMAL(2副本), HIGH(3副本), EXTERN
    TOTAL_MB/1024 AS TOTAL_GB, 
    FREE_MB/1024 AS FREE_GB,
    HOT_READS, HOT_WRITES         -- 观察热点读写
FROM V$ASM_DISKGROUP;

-- 查看物理磁盘的 I/O 响应时间（非常关键！）
-- 如果平均读写时间超过 5-10ms，说明 SSD 已经过载或有瓶颈
SELECT 
    GROUP_NUMBER, 
    PATH, 
    READ_TIME, 
    WRITE_TIME, 
    READS, 
    WRITES 
FROM V$ASM_DISK_STAT;

-- 查看排名前五的等待事件
SELECT * FROM (
    SELECT EVENT, TOTAL_WAITS, TIME_WAITED_MICRO 
    FROM V$SYSTEM_EVENT 
    ORDER BY TIME_WAITED_MICRO DESC
) WHERE ROWNUM <= 5;

SELECT 
    INSTANCE_NAME,    -- 实例名称（如 node1, node2）
    HOST_NAME,        -- 物理服务器名称
    STATUS,           -- 状态（OPEN）
    VERSION           -- 版本
FROM V$INSTANCE;
或者，如果你想查看当前集群中所有的实例以及你所在的 ID：
SELECT 
    USERENV('INSTANCE') AS my_instance_id, 
    inst_id, 
    instance_name 
FROM gv$instance;

SELECT 
    INSTANCE_NAME,    -- 实例名
    HOST_NAME,        -- 物理服务器主机名（通常主机名会带机房标识，如 DC1-DB01）
    (SELECT VALUE FROM V$PARAMETER WHERE NAME = 'db_unique_name') as DB_NAME -- 数据库唯一名
FROM V$INSTANCE;


• REVERSE INDEX： 必须保持。它把这 200 次写入打散到不同的内存块中。
• Sequence CACHE 5000： 必须保持。如果 Cache 太小，这 200 个请求会为了取号在 row cache lock 上排队。
• INITRANS 50： 必须保持。确保每个数据块都有足够的“停车位”给这 200 个并发事务。

诊断你的 200 RPS 瓶颈
请在压测时运行这个 SQL，看看你的 Service 到不到 200 RPS 是被谁挡住了：
SELECT event, total_waits, time_waited 
FROM v$session_event 
WHERE sid IN (SELECT sid FROM v$session WHERE program LIKE '%your_service_name%')
ORDER BY time_waited DESC;

1. 查询表的 INITRANS
SELECT 
    owner, 
    table_name, 
    ini_trans, 
    max_trans, 
    partitioned
FROM all_tables 
WHERE owner = '你的SCHEMA名' -- 注意大写
  AND table_name = '你的表名';
查询索引的 INITRANS (最关键)
SELECT 
    owner, 
    index_name, 
    table_name, 
    ini_trans, 
    max_trans
FROM all_indexes 
WHERE owner = '你的SCHEMA名' 
  AND table_name = '你的表名';

-- 修改表
ALTER TABLE 你的表名 INITRANS 50;

-- 修改索引 (修改后通常需要重建索引以生效)
ALTER INDEX 你的索引名 INITRANS 50 REBUILD ONLINE;

